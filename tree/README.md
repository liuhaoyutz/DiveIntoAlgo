# Python中的二叉树

二叉树（Binary Tree）是一种每个节点最多有两个子节点的树形数据结构。  
  
二叉树的特点  
&emsp;每个节点最多有两棵子树，分别称为左子树和右子树。  
&emsp;左子树和右子树是有顺序的，次序不能任意颠倒。  
&emsp;即使树中某节点只有一棵子树，也要区分它是左子树还是右子树。  
  
二叉树的种类  
&emsp;满二叉树（Full Binary Tree）：除了叶子节点外，每一个节点都恰好有两个子节点。  
&emsp;完全二叉树（Complete Binary Tree）：除最后一层外，其它各层的节点数目均已达最大值，且最后一层的节点都集中在该层最左边。  
&emsp;平衡二叉树（Balanced Binary Tree）：又被称为AVL树，它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。  
    
二叉搜索树（Binary Search Tree, BST）是一种特殊的二叉树，它具有以下性质：  
&emsp;对于任意节点n，其左子树中的所有节点的值都小于n的值；  
&emsp;对于任意节点n，其右子树中的所有节点的值都大于n的值；  
&emsp;左子树和右子树也分别是二叉搜索树。  
这些性质使得二叉搜索树非常适合用于需要快速查找、插入和删除操作的应用场景。由于每个节点的值与它的左右子树中的所有节点值都有明确的关系，  
所以可以在O(h)的时间复杂度内完成查找、插入或删除操作，其中h是树的高度。在最坏情况下（例如树完全不平衡），时间复杂度可能会退化到O(n)，  
但在平均情况下，如果树保持平衡，那么这些操作的时间复杂度接近于O(log n)。  
  
AVL树（Adelson-Velsky and Landis Tree）是一种自平衡二叉搜索树。在AVL树中，任何节点的两个子树的高度最大差别为1，因此它也被称为高度平衡树。  
AVL树通过确保树的高度保持对数级别（O(log n)），从而保证了查找、插入和删除操作的时间复杂度不会超过O(log n)。  
  
AVL树是通过旋转操作来维持平衡的。当插入或删除一个节点导致树失去平衡时，会执行一种或多种旋转操作（单旋转或双旋转）以恢复平衡。这些旋转包括：  
&emsp;左旋转（Left Rotation）：用于修正右重的情况。  
&emsp;右旋转（Right Rotation）：用于修正左重的情况。  
&emsp;左右旋转（Left-Right Rotation）：先对左子树进行左旋转，然后对根节点进行右旋转，用于修正左子树右重的情况。  
&emsp;右左旋转（Right-Left Rotation）：先对右子树进行右旋转，然后对根节点进行左旋转，用于修正右子树左重的情况。  
  
### License  
  
MIT
